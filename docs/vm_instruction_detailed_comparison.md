# VM指令详细对比表

## 指令实现状态对比表

| 操作码 | 官方Lua 5.1.5语义 | 当前项目实现 | 合规状态 | 问题描述 |
|--------|-------------------|-------------|----------|----------|
| **基础数据操作** |
| MOVE | `R(A) := R(B)` | `base[a] = base[b]` | ✅ 完全合规 | 实现正确 |
| LOADK | `R(A) := Kst(Bx)` | `base[a] = constants[bx]` | ✅ 完全合规 | 实现正确 |
| LOADBOOL | `R(A) := (Bool)B; if (C) pc++` | 支持条件跳转 | ✅ 完全合规 | 实现正确 |
| LOADNIL | `R(A) := ... := R(B) := nil` | 循环设置nil | ✅ 完全合规 | 实现正确 |
| GETUPVAL | `R(A) := UpValue[B]` | 返回nil占位 | ❌ 占位实现 | 需要实现真正的上值 |
| **全局变量操作** |
| GETGLOBAL | `R(A) := Gbl[Kst(Bx)]` | 使用L->getGlobal | ✅ 完全合规 | 实现正确 |
| SETGLOBAL | `Gbl[Kst(Bx)] := R(A)` | 使用L->setGlobal | ✅ 完全合规 | 实现正确 |
| **表操作** |
| GETTABLE | `R(A) := R(B)[RK(C)]` | 基础表访问 | ⚠️ 部分合规 | 缺少元方法支持 |
| SETTABLE | `R(A)[RK(B)] := RK(C)` | 基础表设置 | ⚠️ 部分合规 | 缺少元方法支持 |
| NEWTABLE | `R(A) := {} (size = B,C)` | 创建空表 | ⚠️ 部分合规 | 忽略大小参数 |
| SELF | `R(A+1) := R(B); R(A) := R(B)[RK(C)]` | 简化实现 | ❌ 不完整 | 第二部分未实现 |
| **算术运算** |
| ADD | `R(A) := RK(B) + RK(C)` | 基础加法 | ⚠️ 部分合规 | 缺少元方法支持 |
| SUB | `R(A) := RK(B) - RK(C)` | 基础减法 | ⚠️ 部分合规 | 缺少元方法支持 |
| MUL | `R(A) := RK(B) * RK(C)` | 基础乘法 | ⚠️ 部分合规 | 缺少元方法支持 |
| DIV | `R(A) := RK(B) / RK(C)` | 基础除法 | ⚠️ 部分合规 | 缺少元方法支持 |
| MOD | `R(A) := RK(B) % RK(C)` | 基础取模 | ⚠️ 部分合规 | 缺少元方法支持 |
| POW | `R(A) := RK(B) ^ RK(C)` | 基础幂运算 | ⚠️ 部分合规 | 缺少元方法支持 |
| UNM | `R(A) := -R(B)` | 基础负号 | ⚠️ 部分合规 | 缺少元方法支持 |
| NOT | `R(A) := not R(B)` | 逻辑非 | ✅ 完全合规 | 实现正确 |
| LEN | `R(A) := length of R(B)` | 字符串/表长度 | ⚠️ 部分合规 | 缺少元方法支持 |
| **字符串操作** |
| CONCAT | `R(A) := R(B).. ... ..R(C)` | 简化两值连接 | ❌ 不完整 | 不支持多值连接 |
| **控制流** |
| JMP | `pc+=sBx` | 直接跳转 | ✅ 完全合规 | 实现正确 |
| **比较运算** |
| EQ | `if ((RK(B) == RK(C)) ~= A) then pc++` | 错误：存储结果到寄存器 | ❌ 语义错误 | 应该是条件跳转 |
| LT | `if ((RK(B) < RK(C)) ~= A) then pc++` | 错误：存储结果到寄存器 | ❌ 语义错误 | 应该是条件跳转 |
| LE | `if ((RK(B) <= RK(C)) ~= A) then pc++` | 错误：存储结果到寄存器 | ❌ 语义错误 | 应该是条件跳转 |
| **条件测试** |
| TEST | `if not (R(A) <=> C) then pc++` | 实现跳转逻辑 | ⚠️ 部分合规 | 包含调试输出 |
| TESTSET | `if (R(B) <=> C) then R(A) := R(B) else pc++` | 基础实现 | ⚠️ 部分合规 | 需要验证逻辑 |
| **函数调用** |
| CALL | 复杂的函数调用机制 | 支持Lua/Native函数 | ⚠️ 部分合规 | 实现较复杂，需验证 |
| TAILCALL | 尾调用优化 | 占位实现 | ❌ 占位实现 | 需要实现真正的尾调用 |
| RETURN | 函数返回处理 | 支持多返回值 | ⚠️ 部分合规 | 实现复杂，需验证 |
| **循环控制** |
| FORLOOP | 数值for循环 | 支持正负步长 | ✅ 完全合规 | 实现正确 |
| FORPREP | for循环准备 | 类型转换和准备 | ✅ 完全合规 | 实现正确 |
| TFORLOOP | 泛型for循环 | 占位实现 | ❌ 占位实现 | 需要完整实现 |
| **高级功能** |
| SETLIST | 列表批量设置 | 占位实现 | ❌ 占位实现 | 需要完整实现 |
| CLOSE | 关闭上值 | 占位实现 | ❌ 占位实现 | 需要上值系统 |
| CLOSURE | 创建闭包 | 基础实现 | ⚠️ 部分合规 | 需要完整上值支持 |
| VARARG | 可变参数 | 简化实现 | ❌ 不完整 | 需要完整实现 |
| SETUPVAL | 设置上值 | 占位实现 | ❌ 占位实现 | 需要上值系统 |

## 统计摘要

### 按合规状态分类
- ✅ **完全合规**: 8个指令 (21%)
  - MOVE, LOADK, LOADBOOL, LOADNIL, GETGLOBAL, SETGLOBAL, NOT, JMP, FORLOOP, FORPREP
  
- ⚠️ **部分合规**: 15个指令 (39%)
  - GETTABLE, SETTABLE, NEWTABLE, ADD, SUB, MUL, DIV, MOD, POW, UNM, LEN, TEST, TESTSET, CALL, RETURN, CLOSURE
  
- ❌ **不合规/不完整**: 15个指令 (39%)
  - GETUPVAL, SELF, CONCAT, EQ, LT, LE, TAILCALL, TFORLOOP, SETLIST, CLOSE, VARARG, SETUPVAL

### 按功能分类的合规率
- **基础数据操作**: 80% (4/5完全合规)
- **全局变量操作**: 100% (2/2完全合规)  
- **表操作**: 25% (1/4完全合规)
- **算术运算**: 11% (1/9完全合规)
- **字符串操作**: 0% (0/1完全合规)
- **控制流**: 100% (1/1完全合规)
- **比较运算**: 0% (0/3完全合规)
- **条件测试**: 0% (0/2完全合规)
- **函数调用**: 0% (0/3完全合规)
- **循环控制**: 67% (2/3完全合规)
- **高级功能**: 0% (0/5完全合规)

## 关键问题分析

### 1. 比较指令的根本性错误
比较指令(EQ, LT, LE)的实现完全违背了Lua 5.1的语义：
- **官方**: 条件跳转指令，根据比较结果决定是否跳转
- **当前**: 错误地实现为存储指令，将比较结果存储到寄存器

### 2. 元方法支持缺失
大部分算术和比较运算缺少元方法支持，这是Lua语言的核心特性。

### 3. 上值系统未实现
闭包相关的指令(GETUPVAL, SETUPVAL, CLOSE)都是占位实现，影响闭包功能。

### 4. 高级指令实现不足
泛型for循环、列表设置、可变参数等高级功能实现不完整。

## 修复建议

### 立即修复 (P0)
1. 修复比较指令的条件跳转语义
2. 移除调试输出代码
3. 完善CONCAT指令的多值连接

### 高优先级 (P1)  
1. 实现基础元方法支持
2. 完善函数调用机制
3. 实现上值系统基础框架

### 中优先级 (P2)
1. 完善高级指令实现
2. 优化性能关键路径
3. 增强错误处理机制
