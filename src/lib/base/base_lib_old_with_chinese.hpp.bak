#pragma once

#include "../core/lib_define.hpp"
#include "../core/lib_func_registry.hpp"
#include "../core/lib_context.hpp"
#include "../core/lib_module.hpp"
#include "../../vm/state.hpp"
#include "../../vm/value.hpp"
#include "../../vm/table.hpp"

namespace Lua {

// Use library framework types
using namespace Lib;

/**
 * Unified Base Library implementation
 * Contains all Lua 5.1 standard base functions
 * 
 * Design principles:
 * 1. Single implementation path - each function has only one implementation
 * 2. Unified interface specification - uses standard parameter checking and error handling
 * 3. Clear dependency relationships - depends only on necessary modules
 * 4. High cohesion, low coupling - related functionality centralized, reduced external dependencies
 */
class BaseLib : public LibModule {
public:
    // === LibModule Interface Implementation ===
    
    /**
     * Get module name
     */
    StrView getName() const noexcept override { return "base"; }
    
    /**
     * Get module version
     */
    StrView getVersion() const noexcept override { return "1.0.0"; }
    
    /**
     * Register functions to registry
     */
    void registerFunctions(LibFuncRegistry& registry, const LibContext& context) override;
    
    /**
     * Initialize module
     */
    void initialize(State* state, const LibContext& context) override;
    
    /**
     * Cleanup module resources
     */
    void cleanup(State* state, const LibContext& context) override;

public:
    // === Core Base Functions ===
    
    /**
     * print(...) - 输出参数到标准输出
     * 参数：可变参数列表
     * 返回：nil
     */
    LUA_FUNCTION(print);
    
    /**
     * type(v) - 获取值的类型
     * 参数：v - 任意值
     * 返回：类型名称字符串
     */
    LUA_FUNCTION(type);
    
    /**
     * tostring(v) - 将值转换为字符串
     * 参数：v - 任意值
     * 返回：字符串表示
     */
    LUA_FUNCTION(tostring);
    
    /**
     * tonumber(e [, base]) - 将值转换为数字
     * 参数：e - 要转换的值，base - 进制（可选，默认10）
     * 返回：数字或nil（转换失败）
     */
    LUA_FUNCTION(tonumber);
    
    /**
     * error(message [, level]) - 抛出错误
     * 参数：message - 错误消息，level - 错误级别（可选）
     * 返回：不返回（抛出异常）
     */
    LUA_FUNCTION(error);
    
    /**
     * assert(v [, message]) - 断言检查
     * 参数：v - 要检查的值，message - 错误消息（可选）
     * 返回：v（如果为真）
     */
    LUA_FUNCTION(assert_func);

    // === 表操作函数 ===
    
    /**
     * pairs(t) - 创建表的通用迭代器
     * 参数：t - 表
     * 返回：迭代器函数三元组（function, table, nil）
     */
    LUA_FUNCTION(pairs);
    
    /**
     * ipairs(t) - 创建表的数组部分迭代器
     * 参数：t - 表
     * 返回：迭代器函数三元组（function, table, 0）
     */
    LUA_FUNCTION(ipairs);
    
    /**
     * next(table [, index]) - 获取表中下一个键值对
     * 参数：table - 表，index - 当前索引（可选）
     * 返回：下一个键值对或nil
     */
    LUA_FUNCTION(next);

    // === 元表操作函数 ===
    
    /**
     * getmetatable(object) - 获取对象的元表
     * 参数：object - 任意对象
     * 返回：元表或nil
     */
    LUA_FUNCTION(getmetatable);
    
    /**
     * setmetatable(table, metatable) - 设置表的元表
     * 参数：table - 表，metatable - 元表或nil
     * 返回：table
     */
    LUA_FUNCTION(setmetatable);

    // === 原始访问函数 ===
    
    /**
     * rawget(table, index) - 原始获取表元素（忽略元方法）
     * 参数：table - 表，index - 索引
     * 返回：对应的值
     */
    LUA_FUNCTION(rawget);
    
    /**
     * rawset(table, index, value) - 原始设置表元素（忽略元方法）
     * 参数：table - 表，index - 索引，value - 值
     * 返回：table
     */
    LUA_FUNCTION(rawset);
    
    /**
     * rawlen(v) - 获取对象的原始长度（忽略元方法）
     * 参数：v - 字符串或表
     * 返回：长度
     */
    LUA_FUNCTION(rawlen);
    
    /**
     * rawequal(v1, v2) - 原始相等比较（忽略元方法）
     * 参数：v1, v2 - 任意值
     * 返回：布尔值
     */
    LUA_FUNCTION(rawequal);

    // === 错误处理函数 ===
    
    /**
     * pcall(f [, arg1, ...]) - 保护调用函数
     * 参数：f - 要调用的函数，arg1, ... - 参数
     * 返回：成功标志和结果或错误消息
     */
    LUA_FUNCTION(pcall);
    
    /**
     * xpcall(f, err [, arg1, ...]) - 扩展保护调用
     * 参数：f - 要调用的函数，err - 错误处理函数，arg1, ... - 参数
     * 返回：成功标志和结果或错误消息
     */
    LUA_FUNCTION(xpcall);

    // === 工具函数 ===
    
    /**
     * select(index, ...) - 选择参数
     * 参数：index - 索引或"#"，... - 参数列表
     * 返回：选中的参数或参数数量
     */
    LUA_FUNCTION(select);
    
    /**
     * unpack(list [, i [, j]]) - 解包表为参数列表
     * 参数：list - 表，i - 起始索引（可选），j - 结束索引（可选）
     * 返回：表中的元素序列
     */
    LUA_FUNCTION(unpack);

    // === 代码加载函数 ===
    
    /**
     * loadstring(string [, chunkname]) - 从字符串加载代码
     * 参数：string - Lua代码字符串，chunkname - 块名称（可选）
     * 返回：编译后的函数或nil和错误消息
     */
    LUA_FUNCTION(loadstring);
    
    /**
     * load(chunk [, chunkname [, mode [, env]]]) - 通用代码加载器
     * 参数：chunk - 代码块，chunkname - 块名称，mode - 模式，env - 环境
     * 返回：编译后的函数或nil和错误消息
     */
    LUA_FUNCTION(load);

private:
    // === 私有辅助方法 ===
    
    /**
     * 创建迭代器函数（用于pairs和ipairs）
     */
    Value createIterator(const char* name);
    
    /**
     * 获取表的长度（用于rawlen）
     */
    i32 getTableLength(const Value& table);
    
    /**
     * 执行保护调用的通用逻辑
     */
    std::pair<bool, Value> executeProtectedCall(State* state, const Value& func, 
                                               const std::vector<Value>& args,
                                               const Value& errorHandler = Value());
};

/**
 * 最小化 Base Library
 * 仅包含最基础的函数，用于嵌入式或资源受限环境
 */
class MinimalBaseLib : public LibModule {
public:
    // === LibModule 接口实现 ===
    StrView getName() const noexcept override { return "base_minimal"; }
    StrView getVersion() const noexcept override { return "1.0.0"; }
    void registerFunctions(LibFuncRegistry& registry, const LibContext& context) override;
    void initialize(State* state, const LibContext& context) override;

public:
    // === 最小功能集 ===
    LUA_FUNCTION(print);      // 基础输出
    LUA_FUNCTION(type);       // 类型检查
    LUA_FUNCTION(tostring);   // 字符串转换
    LUA_FUNCTION(error);      // 错误处理
};

/**
 * Base Library 工厂函数
 * 提供不同配置的基础库实例
 */
namespace BaseLibFactory {
    /**
     * 创建标准基础库（包含所有函数）
     */
    std::unique_ptr<LibModule> createStandard();
    
    /**
     * 创建最小基础库（仅核心函数）
     */
    std::unique_ptr<LibModule> createMinimal();
    
    /**
     * 根据配置创建基础库
     */
    std::unique_ptr<LibModule> createFromConfig(const LibContext& context);
}

/**
 * 便捷注册函数（向后兼容）
 * 直接将基础库函数注册到Lua状态机
 */
void registerBaseLib(State* state);

/**
 * 高级注册函数（推荐使用）
 * 使用库管理器注册，支持配置和依赖管理
 */
void registerBaseLibManaged(State* state, const LibContext& context = LibContext{});

} // namespace Lua
