# VM/State 架构重构问题跟踪

本文档用于系统记录在 VM/State 架构重构过程中发现的待修复问题，帮助我们在“安全小步”推进过程中不遗漏关键问题，并合理安排优先级与依赖关系。

更新时间：2025-08-11

## 问题分类
- 多返回值传递问题
- 寄存器基址管理问题
- 调用栈/帧管理问题
- 标准库兼容性问题

---

## 一、多返回值传递问题

### 1. 最后实参为函数调用时的多返回值传递（pass(m())）
- 问题描述：
  - 形如 `pass(m())` 的调用场景中，最后一个实参是一个具有多返回值的函数调用。Lua 5.1 语义要求：当函数调用出现在实参列表的最后一个位置时，应将其所有返回值“展开”作为该调用的实参列表的一部分。
- 当前表现：
  - 部分修复完成：编译器已支持最后参数为函数调用的检测和B=0/C=0设置，VM已添加返回段保留逻辑。
  - 仍存在问题：`pass(m())` 执行时出现"Attempt to call a number value"错误，表明寄存器被意外覆盖。
  - 观察：`test_multi_ret.lua` 中：
    - `local a,b,c = m()` -> 正确得到 `nil,10,20`（注意：第一个值为nil，可能存在其他问题）
    - `local x,y = pass(m())` -> 抛出异常，无法完成执行。
- 预期行为（Lua 5.1）：
  - 若 `m()` 返回 `10,20,30`，则 `pass(m())` 在 `pass(...)` 中应收到 `10,20,30`（即最后一个实参的多返回值被展开）。
- 技术分析：
  - 相关指令：`CALL`、`VARARG`
  - 当前 VM 执行路径中，`executeMultiple` 在收集完返回值后会将 `top` 恢复至调用前（为保持上下文整洁），导致随后外层 `CALL`（若使用 `b==0` 以从栈顶取所有参数）无法“看到”刚刚返回并应被展开的值。
  - 正确语义需满足：当内层 `CALL` 的结果被用作外层 `CALL` 的“最后一个实参”时，内层返回值应保留在栈顶供外层 `CALL(b==0)` 消费，或在寄存器层面完成“展开”并被外层调用读取。
- 修复优先级：高
- 依赖关系：
  - 已完成：统一索引语义；`op_call` 参数布局优化；`executeInContextMultiple` Lua 分支在上下文内执行；`op_call` 返回值正确分发。
  - 待办：为“作为最后实参加载”的场景提供返回值展开的时机/协议（例如：
    1) 给 `executeMultiple` 增加“保留返回值在栈上”的可选模式，仅用于“下一条指令立即消费”的场景；或
    2) 在 `op_call` 组装实参阶段，识别“最后一个参数是多返回”的情况，直接从栈顶连续吸收（`b==0`）并避免提前清栈）。

### 2. 多返回值在赋值语句中的传播
- 问题描述：
  - 形如 `local a,b,c = m()` 已正确，但更复杂的链式传播（如 `local x,y = pass(m())`）不正确。
- 当前表现：
  - `test_multi_ret.lua` 的第二段输出为空或不完整。
- 预期行为：
  - 与 Lua 5.1 一致：最后表达式为函数调用时，多返回值可被展开并按目标变量个数截断或补 `nil`。
- 技术分析：
  - 与问题 1 同源，归结为“返回值展开的生命周期”与“后续指令的消费方式（b==0）”未衔接。
- 修复优先级：高
- 依赖关系：同问题 1。

---

## 二、寄存器基址管理问题

### 3. registerBase 推入/弹出的一致性进一步收敛
- 问题描述：
  - 已在 `op_call/op_return` 引入轻量帧化的 base/pc 保存点，但仍有少量场景需要统一（比如个别路径对 `registerBase` 的隐式假设）。
- 当前表现：
  - 功能正确，但可维护性仍有提升空间。
- 预期行为：
  - 统一由 `op_call/op_return`（和 `execute/executeMultiple`）负责保存/恢复，其他位置尽量不“手算”。
- 技术分析：
  - 相关位置：`op_call`、`op_return`、`execute`、`executeMultiple`。
- 修复优先级：中
- 依赖关系：可与多返回值展开并行推进。

---

## 三、调用栈/帧管理问题

### 4. 轻量帧向最小 CallFrame 过渡
- 问题描述：
  - 目前使用局部变量维持“轻量帧”，后续需要过渡到最小化的 `CallFrame`（含 `base/pc/func/nresults`）以提升可读性与一致性。
- 当前表现：
  - 代码已较清晰，但分散管理仍有心智负担。
- 预期行为：
  - 引入最小帧结构，集中管理调用现场（仍保持简洁）。
- 技术分析：
  - 不涉及语义变化，主要是工程化改进。
- 修复优先级：中
- 依赖关系：不阻塞多返回值问题修复，可在其后实施。

---

## 四、标准库兼容性问题

### 5. string.find 的调用兼容
- 问题描述：
  - `string.find("hello world", "world")` 报错；可能因库实现按“模块函数”形态编写（期望 `string.find(str, pattern)` 或 `('string'):find(...)` 的具体约定未统一）。
- 当前表现：
  - 运行时报错信息类似：`string.find: expected ...`（报错截断，需进一步确认具体期望）。
- 预期行为：
  - 与 Lua 5.1 标准库一致（支持常见用法）。
- 技术分析：
  - 需核查 string 库入口的参数绑定策略与 `self` 语义；与 VM 调用语义无强耦合，可独立修复。
- 修复优先级：中
- 依赖关系：无（可独立推进）。

---

## 五、已完成的关键改进（里程碑）
- 统一栈索引语义：`getPtr` 0 基绝对/负相对统一；`getRegPtr` 与之对齐。
- 移除 C 函数调用整栈复制：`callNativeMultiple` 就地协议。
- `op_call` 参数布局优化：一次性在 `top` 建立参数区。
- 轻量帧化：在 `op_call/op_return` 引入局部 `base/pc` 保存恢复点。
- `executeInContext`（Lua）就地执行；`executeInContextMultiple`（Lua）留在 VM 上下文内。
- `op_call` 多返回值分发：`c==0` 分发全部、`c>0` 截断/补 `nil`。

---

## 六、下一步计划（安全小步）
1) 修复“最后实参多返回值展开”（高优先级）：
   - 方案 A（推荐）：为 `executeMultiple` 增加可选“保留返回值在栈上”模式，仅在“下一条为外层 `CALL(b==0)` 消费”时启用；由 `op_call` 在实参组装时根据 `b==0` 与位置判断是否需要该模式。
   - 方案 B：不改 `executeMultiple`，在 `op_call` 识别“最后实参加载为调用且 c==0”的情形时，从寄存器迁移为“从栈顶吸收所有返回值”（需要编译器与 VM 的契约更明确）。
   - 先覆盖 `pass(m())`，再扩展到更一般的链式场景。
2) 继续收敛寄存器基址管理：减少零散“手算”。
3) （可选）推进最小 `CallFrame` 引入（工程化重构，低风险）。

> 注：每一步都将遵循“可编译、可验证、可回退”的原则，并优先使用小范围改动验证关键语义。

